<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Edge-WebGL</title>
    <!-- Twitter Card data -->
    <meta name="twitter:card" value="Edge-GL Demo Rendering">
    <meta name="Description" content="Rendering demo of Edge-GL."/>
    <!-- Open Graph data -->
    <meta property="og:title" content="Edge-GL Demo Rendering" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://github.com/jedgeworth/WebGL-Terrain" />
    <meta property="og:image" content="https://jamesedgeworth.com/logo.svg" />
    <meta property="og:description" content="Rendering demo of Edge-GL." />
    <!-- Mobile header color for Chrome, Firefox OS and Opera -->
    <meta name="theme-color" content="#ff4970">
    <!-- Mobile header color Windows Phone -->
    <meta name="msapplication-navbutton-color" content="#ff4970">
    <!-- Mobile header color for iOS Safari (supports black, black-translucent or default) -->
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700" rel="stylesheet">

    <style>

        h3{
            margin:1rem 0 .5rem 0;
        }

        input {
            max-width:100%;
        }

        #glCanvas{
            position:absolute;
            top:0;
            left:0;
            right:0;
            bottom:0;
            width:100%;
            height:100%;
        }

        #debug{
            position:absolute;
            top:0;
            left:0;
            z-index:1;
        }

        #bottomLeft{
            position:absolute;
            bottom:0;
            left:0;
            padding:1rem;
            color:#fff;
            z-index:1;
        }

        #bottomRight{
            position:absolute;
            bottom:0;
            right:0;
            padding:1rem;
            background:#fff;
            z-index:1;
        }

        #topRight{
            position:absolute;
            top:0;
            right:0;
            width:150px;
            display:block;
            text-align:left;
            padding:1rem;
            z-index:1;
            background:#fff;
        }

        #cameraDebug{
            margin-top:1rem;
        }
    </style>

    <script id="base-vs" type="x-shader/x-vertex">
        precision highp float;
        precision mediump int;

        attribute vec3 a_VertexNormal;
        attribute vec3 a_VertexPosition;
        attribute vec2 a_TextureCoord;

        struct Light {
            vec3 ambient;
            vec3 diffuse;
            vec3 specular;
            vec3 position;
            int type;
        };

        uniform bool u_UseNormalMap;
        uniform bool u_CorrectD3d;
        uniform bool u_UseLighting;
        uniform bool u_UseFog;

        uniform Light u_Lights[2];

        uniform mat4 u_NormalMatrix;
        uniform mat4 u_ModelViewMatrix;
        uniform mat4 u_ProjectionMatrix;

        varying vec2 v_TextureCoord;
        varying vec3 v_Normal;
        varying vec3 v_LightPointPosition[2];
        varying vec3 v_EyeVec;
        varying float v_FogDepth;
        varying vec3 v_RawNormal;

        void main(void) {

            vec4 mvVertex = u_ModelViewMatrix * vec4(a_VertexPosition, 1.0);
            v_Normal = vec3(u_NormalMatrix * vec4(a_VertexNormal, 1.0));
            v_RawNormal = a_VertexNormal;
            v_EyeVec = -vec3(a_VertexPosition);

            if (u_Lights[0].type == 0) {
                v_LightPointPosition[0] = u_Lights[0].position;
            } else {
                v_LightPointPosition[0] = -(u_Lights[0].position - a_VertexPosition);
            }

            if (u_Lights[1].type == 0) {
                v_LightPointPosition[1] = u_Lights[1].position;
            } else {
                v_LightPointPosition[1] = -(u_Lights[1].position - a_VertexPosition);
            }

            v_TextureCoord = a_TextureCoord;
            v_FogDepth = (u_ProjectionMatrix * mvVertex).z;

            //
            gl_PointSize = 2.0;
            gl_Position = u_ProjectionMatrix * u_ModelViewMatrix * vec4(a_VertexPosition, 1.0);
        }
    </script>

    <script id="base-fs" type="x-shader/x-fragment">
        precision highp float;
        precision mediump int;

        struct Light {
            vec3 ambient;
            vec3 diffuse;
            vec3 specular;
            vec3 position;
            int type;
        };


        uniform sampler2D u_Texture0;
        uniform sampler2D u_TextureNormal0;

        uniform sampler2D u_Texture1;
        uniform sampler2D u_TextureNormal1;

        uniform bool u_UseNormalMap;
        uniform bool u_CorrectD3d;
        uniform bool u_UseLighting;
        uniform bool u_UseFog;

        uniform Light u_Lights[2];

        uniform float u_Shininess;


        const vec4 u_MaterialAmbient = vec4(1.0, 1.0, 1.0, 1.0);
        const vec4 u_MaterialDiffuse = vec4(1.0, 1.0, 1.0, 1.0);
        const vec4 u_MaterialSpecular = vec4(1.0, 1.0, 1.0, 1.0);

        uniform vec4 u_FogColor;
        uniform float u_FogNear;
        uniform float u_FogFar;

        varying vec2 v_TextureCoord;
        varying vec3 v_LightPointPosition[2];
        varying vec3 v_Normal;
        varying vec3 v_RawNormal;
        varying vec3 v_EyeVec;
        varying float v_FogDepth;


        //
        // Calculate the lighting.
        // Uses vertex normals combined with a texture's normal map.
        vec4 lighting(Light light, vec3 lightPosition) {

            vec3 L = normalize( lightPosition );
            vec3 N = normalize( v_Normal );

            if (u_UseNormalMap) {
                vec3 normalColor = texture2D(u_Texture1, v_TextureCoord).rgb;

                // Assume normal map is D3D - if so we flip the green value.
                // @todo: Do this on the Texture() loader.
                if (u_CorrectD3d) {
                    normalColor.g *= -1.0;
                }

                vec3 fragmentNormal = normalize( normalColor * 2.0 - 1.0 );
                N = normalize(fragmentNormal + v_Normal);
            }

            float lambertTerm = dot(N, L);

            vec4 Ia = vec4(light.ambient, 1.0) * u_MaterialAmbient;
            vec4 Id = vec4(0.0, 0.0, 0.0, 1.0);
            vec4 Is = vec4(0.0, 0.0, 0.0, 1.0);

            if (lambertTerm > 0.0) {
                Id = vec4(light.diffuse, 1.0) * u_MaterialDiffuse * lambertTerm;
                vec3 E = normalize( v_EyeVec );
                vec3 R = reflect(L, N);
                float specular = pow( max( dot(R, E), 0.0 ), u_Shininess );
                Is = vec4(light.specular, 1.0) * u_MaterialSpecular * specular;
            }

            return (Ia + Id) + Is;
        }

        //
        // Calculate fog.
        vec4 fog(vec4 inFinalColor) {
            float fogAmount = smoothstep( u_FogNear, u_FogFar, v_FogDepth );
            return mix( inFinalColor, u_FogColor, fogAmount );
        }

        //
        //
        void main(void) {

          vec4 finalColor = texture2D(u_Texture0, v_TextureCoord);

          if (u_UseLighting) {
            finalColor = finalColor * (
                lighting(u_Lights[0], v_LightPointPosition[0]) +
                lighting(u_Lights[1], v_LightPointPosition[1])
            );
          }

          if (u_UseFog) {
            finalColor = fog(finalColor);
          }

          //if (v_RawNormal.y < .85 && v_RawNormal.x < .85 && v_RawNormal.z < .85) {
          //    finalColor.r = 255.0;
          //}

          //if (u_UseNormalMap) {
          //  finalColor.r = 1.0;
          //}

          gl_FragColor = finalColor;
        }
    </script>


    <script id="line-vs" type="x-shader/x-vertex">
        #version 100
        attribute highp vec3 a_VertexPosition;
        attribute highp vec3 a_VertexColor;

        uniform highp mat4 u_ModelViewMatrix;
        uniform highp mat4 u_ProjectionMatrix;

        varying highp vec3 v_Color;

        void main(void) {
          gl_Position = u_ProjectionMatrix * u_ModelViewMatrix * vec4(a_VertexPosition, 1.0);
          v_Color = a_VertexColor;
        }
    </script>

    <script id="line-fs" type="x-shader/x-fragment">
        #version 100
        varying highp vec3 v_Color;

        void main(void) {
          gl_FragColor = vec4(v_Color.rgb, 1);
        }
    </script>


    <script id="billboard-vs" type="x-shader/x-vertex">
        #version 100
        precision highp float;

        attribute vec3 a_VertexPosition;
        attribute vec3 a_VertexColor;
        attribute vec2 a_TextureCoord;

        uniform mat4 u_ModelViewMatrix;
        uniform mat4 u_ProjectionMatrix;

        varying vec2 v_TextureCoord;
        varying vec3 v_Color;

        void main(void) {

            mat4 mvMatrix = u_ModelViewMatrix;
            mvMatrix[0][0] = 1.0;
            mvMatrix[0][1] = 0.0;
            mvMatrix[0][2] = 0.0;
            mvMatrix[1][0] = 0.0;
            mvMatrix[1][1] = 1.0;
            mvMatrix[1][2] = 0.0;
            mvMatrix[2][0] = 0.0;
            mvMatrix[2][1] = 0.0;
            mvMatrix[2][2] = 1.0;

            gl_Position = u_ProjectionMatrix * mvMatrix * vec4(a_VertexPosition, 1.0);
            v_Color = a_VertexColor;
            v_TextureCoord = a_TextureCoord;
        }
    </script>

    <script id="billboard-fs" type="x-shader/x-fragment">
        #version 100
        precision highp float;

        varying vec2 v_TextureCoord;
        varying vec3 v_Color;

        uniform sampler2D u_Texture0;

        void main(void) {

            vec4 finalColor = texture2D(u_Texture0, v_TextureCoord);

            if (finalColor.r + finalColor.g + finalColor.b < 0.2) {
                discard;
            }

            gl_FragColor = finalColor;
        }
    </script>


    <script id="terrain-vs" type="x-shader/x-vertex">
        #version 100
        precision highp float;

        attribute vec3 a_VertexNormal;
        attribute vec3 a_VertexPosition;
        attribute vec2 a_TextureCoord;
        attribute vec3 a_VertexColor;

        uniform mat4 u_NormalMatrix;
        uniform mat4 u_ModelViewMatrix;
        uniform mat4 u_ProjectionMatrix;

        uniform sampler2D u_Texture0;
        uniform sampler2D u_Texture1;

        uniform vec3 u_Light0Ambient;
        uniform vec3 u_Light0Diffuse;
        uniform vec3 u_Light0Specular;
        uniform vec3 u_Light0Position;


        varying vec3 v_VertexNormal;
        varying vec3 v_EyeVector;

        varying vec3 v_VertexPosition;

        varying vec4 v_MvmVertexPosition;
        varying vec4 v_MvpmVertexPosition;

        varying vec2 v_TextureCoord;
        varying vec3 v_Color;

        void main(void)
        {
            vec4 v4VertexPosition = vec4(a_VertexPosition, 1.0);

            v_VertexNormal = vec3( normalize(u_NormalMatrix * vec4(a_VertexNormal, 1.0)) );

            //vertexLightPosition = normalize(u_Light0Position.xyz);
            v_EyeVector = normalize( -vec3(u_ModelViewMatrix * v4VertexPosition) );

            v_TextureCoord.st = a_TextureCoord.st;

            v_VertexPosition = a_VertexPosition;
            v_MvmVertexPosition = u_ModelViewMatrix * v4VertexPosition;
            v_MvpmVertexPosition = u_ModelViewMatrix * u_ProjectionMatrix * v4VertexPosition;

            v_Color = a_VertexColor;
            gl_Position = v_MvpmVertexPosition;
        }
    </script>

    <script id="terrain-fs" type="x-shader/x-fragment">
        #version 100
        precision highp float;

        varying vec3 v_VertexNormal;
        varying vec3 v_EyeVector;

        varying vec3 v_VertexPosition;
        varying vec2 v_TextureCoord;

        uniform sampler2D u_Texture0;
        uniform sampler2D u_Texture1;

        uniform vec3 u_Light0Ambient;
        uniform vec3 u_Light0Diffuse;
        uniform vec3 u_Light0Specular;
        uniform vec3 u_Light0Position;

        varying vec4 v_MvmVertexPosition;
        varying vec4 v_MvpmVertexPosition;

        vec4 lighting(int lightIndex)
        {
            vec4 color;

            vec3 lightPosition = normalize(u_Light0Position.xyz);

            vec3 fragmentNormal = normalize(texture2D(u_Texture1, v_TextureCoord.st).rgb * 2.0 - 1.0);
            //vec3 normal = normalize(fragmentNormal * v_VertexNormal);
            vec3 normal = v_VertexNormal;
            //vec3 normal = fragmentNormal;

            color = vec4(u_Light0Ambient, 1.0);

            // Diffuse
            float vertexDiffuseValue = max(dot(normal, lightPosition), 0.0);
            float fragmentDiffuseValue = max(dot(normal, lightPosition), 0.0);

            color += fragmentDiffuseValue;

            // Specular
            float shininess = 0.8;

            vec3 reflectVector = normalize(-reflect(lightPosition, normal));

            vec4 specular = vec4(u_Light0Specular, 1.0) * pow(max(dot(reflectVector, v_EyeVector), 0.0), shininess);

            color += specular;
            return color;
        }

        void main()
        {
            //if (dot(mvpmVertexPosition, gl_ClipPlane[0]) > 0.0) {
            //if (gl_Position.y > gl_ClipPlane[0].y) {

                vec4 texturing = texture2D(u_Texture0, v_TextureCoord.st);

                gl_FragColor = texturing * lighting(0);

            //} else {
            //    discard;
            //}

            gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
        }

    </script>

</head>
    <body>
        <div id="debug"></div>


        <div id="topRight">
            <h3>Render options</h3>
            <input type="radio" name="renderModeOverride" value="0" checked>
            <label for="renderModeOverride">Render default</label><br>

            <input type="radio" name="renderModeOverride" value="1">
            <label for="renderModeOverride">Render as lines</label><br>

            <input type="radio" name="renderModeOverride" value="2">
            <label for="renderModeOverride">Render as points</label><br>

            <input type="checkbox" name="renderNormals" value="1">
            <label for="renderNormals">Render normals</label><br>

            <h3>Sunlight</h3>

            <label>
                Type<br>
                <select class="sunType" id="sunType" name="sunType">
                    <option value="0">Directional</option>
                    <option value="1" selected>Point light</option>
                    <option value="2">Spot light</option>
                </select>
            </label>
            <br><br>
            <label>
                Normal mapping<br>
                <select class="normalMapping" id="normalMapping" name="normalMapping">
                    <option value="0">Off</option>
                    <option value="1" selected>On</option>
                </select>
            </label><br><br>

            <label>
                Correct D3D<br>
                <select class="correctD3d" id="correctD3d" name="correctD3d">
                    <option value="0">Off</option>
                    <option value="1" selected>On</option>
                </select>
            </label><br><br>

            <label>
                Shininess
                <input class="shininess" type="range" min="0.0" max="1.0" step="0.1" id="shininess" name="shininess" value="1.0">
            </label>

            <label>
                Diffuse R
                <input class="diffuse" type="range" min="0.0" max="1" step="0.1" id="diffuseR" name="diffuseR" value="0.7">
            </label>

            <label>
                Diffuse G
                <input class="diffuse" type="range" min="0.0" max="1" step="0.1"  id="diffuseG" name="diffuseG" value="0.7">
            </label>

            <label>
                Diffuse B
                <input class="diffuse" type="range" min="0.0" max="1" step="0.1"  id="diffuseB" name="diffuseB" value="0.7">
            </label>

            <label>
                Specular R
                <input class="specular" type="range" min="0.0" max="1" step="0.1"  id="specularR" name="specularR" value="0.2">
            </label>

            <label>
                Specular G
                <input class="specular" type="range" min="0.0" max="1" step="0.1"  id="specularG" name="specularG" value="0.2">
            </label>

            <label>
                Specular B
                <input class="specular" type="range" min="0.0" max="1" step="0.1"  id="specularB" name="specularB" value="0.2">
            </label>

            <br>
            <label>
                X
                <input class="sunPos" type="text" id="sunPosX" name="sunPosX" value="1.0">
            </label>

            <label>
                Y
                <input class="sunPos" type="text" id="sunPosY" name="sunPosY" value="-1.0">
            </label>

            <label>
                Z
                <input class="sunPos" type="text" id="sunPosZ" name="sunPosZ" value="1.0">
            </label>

            <h3>Fog</h3>
            <label>
                Near
                <input class="fog" type="text" id="fogNear" name="fogNear" value="1000">
            </label>

            <label>
                Far
                <input class="fog" type="text" id="fogFar" name="fogFar" value="5000.0">
            </label>

            <div id="cameraDebug"></div>
        </div>

        <div id="bottomRight">
            Controls:
            <b>W,A,S,D</b> = movement;
            <b>Space,Q</b> = Up, Down;
            <b>Arrow keys</b> = rotation;
            <b>R, F</b> = Increment/decrement camera speed
        </div>

        <div id="bottomLeft">
            WebGL Demo by <a href="https://jamesedgeworth.com">James Edgeworth</a>
        </div>

        <canvas id="glcanvas" style="width:100%; height:100%">
            Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
        </canvas>
    </body>
</html>
